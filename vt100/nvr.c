#include "vt100.h"

//ER1400 device.

static u16 word[100];
static u8 nvr_latch;
static u32 nvr_addr;
static u16 nvr_data;

static u8 nvr_in (u8 port)
{
  logger ("NVR", "IN"); 
  return 0;
}

static void nvr_out (u8 port, u8 data)
{
  //logger ("NVR", "OUT %02X", data); 
  nvr_latch = data;
}

static u32 word_addr (void)
{
  int i, ones = 0, tens = 0;
  u32 addr = ~nvr_addr;
  for (i = 0; i < 10; i++, addr >>= 1) {
    if (addr & 1)
      tens = 9 - i;
  }
  for (i = 0; i < 10; i++, addr >>= 1) {
    if (addr & 1)
      ones = 9 - i;
  }
  return 10 * tens + ones;
}

void nvr_clock (void)
{
  u32 addr;
  u8 bit = nvr_latch & 1;
  switch ((nvr_latch >> 1) & 7) {
  case 0: //Accept Data.
    nvr_data <<= 1;
    nvr_data |= bit;
    nvr_data &= 0x3FFF;
    //logger ("NVR", "data shift in (%04X)", nvr_data);
    break;
  case 1: //Accept Address.
    nvr_addr <<= 1;
    nvr_addr |= bit;
    nvr_addr &= 0xFFFFF;
    //logger ("NVR", "address shift in (%05X)", nvr_addr);
    break;
  case 2: //Shift Data Out.
    //logger ("NVR", "data shift out (%04X", nvr_data);
    nvr_data <<= 1;
    vt100_flags &= ~0x20;
    if (nvr_data & 0x4000)
      vt100_flags |= 0x20;
    nvr_data &= 0x3FFF;
    break;
  case 3:
    break;
  case 4: //Write.
    nvr_data &= 0x3FFF;
    addr = word_addr ();
    if (addr < 100) {
      word[addr] = nvr_data;
      logger ("NVR", "write %02d, %04X", addr, nvr_data);
    }
    break;
  case 5: //Erase.
    addr = word_addr ();
    if (addr < 100) {
      word[addr] = 0X3FFF;
      logger ("NVR", "erase %02d", addr);
    }
    break;
  case 6: //Read.
    addr = word_addr ();
    if (addr < 100) {
      nvr_data = word[addr];
      logger ("NVR", "read %02d, %04X", addr, nvr_data);
    }
    break;
  case 7: //Standby.
    //logger ("NVR", "stand by");
    break;
  }
}

static u16 defaults[100] = {
#if 1
  //jeffpar
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E00,
  0x2E08, 0x2E8E, 0x2E00, 0x2ED0, 0x2E70, 0x2E00, 0x2E20, 0x2E00,
  0x2EE0, 0x2EE0, 0x2E7D, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000
#else
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80,
  0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E80, 0x2E00,
  0x2E08, 0x2E8E, 0x2E20, 0x2ED0, 0x2E50, 0x2E00, 0x2E20, 0x2E00,
  0x2EE0, 0x2EE0, 0x2E69, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
  0x0000, 0x0000, 0x0000, 0x0000
#endif
};

void reset_nvr (void)
{
  int i;
  register_port (0x62, nvr_in, nvr_out);
  nvr_data = 0;
  nvr_addr = 0;
  for (i = 0; i < 100; i++)
    //word[i] = 0x3FFF;
    word[i] = defaults[i];
}
